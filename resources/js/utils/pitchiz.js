// Generated by Haxe 3.4.7
(function ($hx_exports) { "use strict";
$hx_exports["pitchiz"] = $hx_exports["pitchiz"] || {};
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
EReg.prototype = {
	match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw new js._Boot.HaxeError("EReg::matched");
		}
	}
};
var HxOverrides = function() { };
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
var Std = function() { };
Std.parseInt = function(x) {
	var v = parseInt(x,10);
	if(v == 0 && (HxOverrides.cca(x,1) == 120 || HxOverrides.cca(x,1) == 88)) {
		v = parseInt(x);
	}
	if(isNaN(v)) {
		return null;
	}
	return v;
};
var js = {};
js._Boot = {};
js._Boot.HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js._Boot.HaxeError);
	}
};
js._Boot.HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js._Boot.HaxeError(val);
	}
};
js._Boot.HaxeError.__super__ = Error;
js._Boot.HaxeError.prototype = $extend(Error.prototype,{
});
var pitchiz = {};
pitchiz.Pitchiz = $hx_exports["pitchiz"]["Pitchiz"] = function() { };
pitchiz.Chroma = $hx_exports["pitchiz"]["Chroma"] = function(index) {
	if(index == null) {
		index = 9;
	}
	this.index = index;
};
pitchiz.Chroma.createFromName = function(name) {
	var found = false;
	var index = -1;
	name = name.split("#").join("♯").split("b").join("♭");
	name = name.split("D♯").join("E♭").split("A♯").join("B♭").split("D♭").join("C♯").split("G♭").join("F♯").split("A♭").join("G♯");
	while(!found && index < pitchiz.Chroma.Names.length) {
		++index;
		found = name == pitchiz.Chroma.Names[index];
	}
	if(found) {
		return new pitchiz.Chroma(index);
	}
	return null;
};
pitchiz.Chroma.getInterval = function(chroma1,chroma2) {
	var interval = chroma1.index - chroma2.index;
	return interval;
};
pitchiz.Chroma.prototype = {
	addInterval: function(interval) {
		var newIndex = (this.index + interval) % 12;
		if(newIndex < 0) {
			newIndex += 12;
		}
		return new pitchiz.Chroma(newIndex);
	}
	,toString: function() {
		return pitchiz.Chroma.Names[this.index];
	}
};
pitchiz.Note = $hx_exports["pitchiz"]["Note"] = function(noteChroma,noteOctave) {
	this.chroma = noteChroma;
	this.octave = noteOctave;
};
pitchiz.Note.findNoteInString = function(str) {
	var r = pitchiz.Note.NameRegex;
	if(r.match(str)) {
		var chroma = pitchiz.Chroma.createFromName(r.matched(1));
		var octave = Std.parseInt(r.matched(2));
		return new pitchiz.Note(chroma,octave);
	}
	return null;
};
pitchiz.Note.getInterval = function(note1,note2) {
	var octaveDelta = note1.octave - note2.octave;
	var interval = pitchiz.Chroma.getInterval(note1.chroma,note2.chroma);
	return octaveDelta * 12 + interval | 0;
};
pitchiz.Note.prototype = {
	addInterval: function(interval) {
		var newChroma = this.chroma.addInterval(interval);
		var newOctave = this.octave + Math.floor(interval / 12);
		return new pitchiz.Note(newChroma,newOctave);
	}
	,getKey: function(kbd) {
		return kbd.getKeyFromNote(this);
	}
	,toString: function() {
		return this.chroma.toString() + (this.octave | 0);
	}
};
pitchiz.Scale = $hx_exports["pitchiz"]["Scale"] = function(chroma,mode) {
	this.chroma = chroma;
	this.mode = mode;
};
pitchiz.Scale.prototype = {
	get_circle5thIndex: function() {
		var shift = this.mode ? 0 : 3;
		return (this.chroma.index + shift) * 7 % 12 + 1;
	}
	,transpose: function(transposition) {
		return new pitchiz.Scale(this.chroma.addInterval(transposition),this.mode);
	}
	,toString: function() {
		var min = this.mode ? "" : "m";
		return this.chroma.toString() + min;
	}
	,equals: function(other) {
		if(this.chroma.index == other.chroma.index) {
			return this.mode == other.mode;
		} else {
			return false;
		}
	}
	,isRelativeTo: function(other) {
		if(this.get_circle5thIndex() == other.get_circle5thIndex()) {
			return this.mode != other.mode;
		} else {
			return false;
		}
	}
};
pitchiz.MIDIKey = $hx_exports["pitchiz"]["MIDIKey"] = function(midiKeyboard,index) {
	this.midiKeyboard = midiKeyboard;
	this.index = index;
};
pitchiz.MIDIKey.prototype = {
	getNote: function() {
		return this.midiKeyboard.lowestNote.addInterval(this.index);
	}
	,getFrequency: function() {
		if(this.index == pitchiz.Pitchiz.A440Index) {
			return pitchiz.Pitchiz.A440Freq;
		}
		return pitchiz.Pitchiz.A440Freq * Math.pow(pitchiz.Pitchiz.TwelfthRootOf2,this.index - pitchiz.Pitchiz.A440Index);
	}
	,toString: function() {
		return this.getNote().toString() + " (" + this.index + ")";
	}
};
pitchiz.MIDIKeyboard = $hx_exports["pitchiz"]["MIDIKeyboard"] = function(lowestOctave) {
	this.lowestOctave = lowestOctave;
	var c = new pitchiz.Chroma(0);
	this.lowestNote = new pitchiz.Note(c,lowestOctave);
};
pitchiz.MIDIKeyboard.prototype = {
	getKey: function(keyIndex) {
		return new pitchiz.MIDIKey(this,keyIndex);
	}
	,getNote: function(keyIndex) {
		return this.getKey(keyIndex).getNote();
	}
	,getKeyFromNote: function(note) {
		return new pitchiz.MIDIKey(this,pitchiz.Note.getInterval(note,this.lowestNote));
	}
	,getKeyFromFrequency: function(freq) {
		var freqRatio = freq / 440.0;
		var keyIndex = pitchiz.Pitchiz.A440Index + 12 * Math.log(freqRatio) / Math.log(2.0);
		return this.getKey(Math.round(keyIndex) | 0);
	}
};
pitchiz.Pitchiz.A440Freq = 440.0;
pitchiz.Pitchiz.A440Index = 69;
pitchiz.Pitchiz.TwelfthRootOf2 = Math.pow(2,0.083333333333333329);
pitchiz.Chroma.Names = ["C","C♯","D","E♭","E","F","F♯","G","G♯","A","B♭","B"];
pitchiz.Note.NameRegex = new EReg("([A-G][#b♯♭]{0,1})(-{0,1}[0-9])","");
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this);
